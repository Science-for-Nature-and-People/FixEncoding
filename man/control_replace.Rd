% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/control_replace.R
\name{control_replace}
\alias{control_replace}
\title{Replace UTF-8 control bytes.}
\usage{
control_replace(dset, enc_check_results, column_name, rep_str)
}
\arguments{
\item{dset}{A data.frame or data.table. Or, if you previously called
diamond_replace.R and saved the output, the data.table it returned.}

\item{enc_check_results}{A list returned by calling
\code{check_column_encoding}.}

\item{column_name}{The name of an element in the list returned by
\code{check_column_encoding}, or a column header in \code{dset} or the
data.table returned by diamond_replace.R. These are all equivalent.}

\item{rep_str}{A matrix. The number of rows should equal the length of
\code{enc_check_results[[column_name]]}. The number of columns should equal
the maximum number of control bytes sequences observed in any element of
\code{enc_check_results[[column_name]]}. Elements within each row of this
matrix are the replacement characters for each control byte sequence
observed in the corresponding elements of
\code{enc_check_results[[column_name]]}, or a random filler character or
string. Because some elements of \code{enc_check_results[[column_name]]} may
have more control byte sequences than others, and because the number of
columns in the replacement matrix is equal to the maximum number of
sequences, some matrix rows may need dummy strings in order to be completely
filled. This matrix must be manually constructed, as there is no method for
guessing the proper ASCII or UTF-8 character to replace an invalid byte
sequence. The function is only capable of replacing single columns at a
time. To replace additional columns, the data.table returned by this
function must be fed back into the function as the value of
\code{dset}--likely with a different value for \code{rep_str}. While this
may seem like an error-prone approach, remember that you can script your
manual construction. A good idea is to use the same filler word throughout
your matrix. Then call \code{grep} using that filler word as the value of
the \code{pattern} argument and the result of calling \code{control_replace}
as the value of argument \code{x}. If the filler word is matched, it
probably means that you missed a secondary, tertiary, etc. byte sequence
lurking in the corresponding element of
\code{enc_check_results[[column_name]]}. (It's happened to me at least
once!). Finally, if you simply want to get rid of a control character
without substituting another character, simply use \code{""} as the value of
that matrix element, as you normally would with \code{sub} pr \code{gsub}.}
}
\value{
A data.table with the same structure as \code{dset}.
}
\description{
Replace control bytes detected by \code{check_column_encoding}
 with valid ASCII or UTF-8 characters. Involves manual construction of a
 replacement matrix (see \code{rep_str}). Control bytes are represented by
 a backslash followed by lowercase-u and a series of hexadecimal numbers.
}

